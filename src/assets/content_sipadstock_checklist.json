{
  "categories": {
    "login": {
      "title": "Login",
      "summary": "Questa categoria racchiude il processo di Login e Logout.",
      "slug": "login",
      "items": ["Z2guUQd", "Z1ohpIo"]
    },
    "stock": {
      "title": "Stock",
      "summary": "Questa categoria racchiude tutto ciò che riguarda la griglia stock e i relativi gridsettings.",
      "slug": "stock",
      "items": ["1pQWxn", "NEzhm", "Z2qKc11", "Z1eHhoR", "2eREkv"]
    },
    "settings": {
      "title": "Settings",
      "summary": "Questa categoria racchiude tutto ciò che riguarda il configuratore.",
      "slug": "settings",
      "items": ["2rF4Hq", "ZXcqct", "ZXTLWo", "Z1eEvQQ", "1KaHiT", "2oN0jv"]
    }
  },
  "items": {
    "Z2guUQd": {
      "id": "Z2guUQd",
      "slug": "sign-in",
      "category": "login",
      "title": "sign-in",
      "content": "<h3>Descrizione</h3>\n<p>Performing a deep comparison of objects in JavaScript is a quite costly operation. Reference checks however, are extremely fast and easy. For that reason, Angular and lots of other libraries depend on reference check comparisons instead of deeply comparing objects. If you mutate objects, you most likely experience weird and unexpected behavior when using any of these libs.</p>\n<p>Here are some examples of things that don’t work properly when mutating objects are:</p>\n<ul>\n<li><code>OnPush</code> ChangeDetectionStrategy in Angular</li>\n<li>NgRx selectors</li>\n<li>RxJS operators such as <code>distinct</code>, <code>distinctUntilChanged</code>, <code>tap</code>, …</li>\n</ul>\n<h3>Solution</h3>\n<p>Instead of mutating objects, we need to work immutable. Immutability means that we will never mutate objects. Instead, if we need to update state or some object properties, we first copy the object and then make our changes.</p>\n<p>This can easily be done with the object/array spread operator:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// Original State</span>\n<span class=\"hljs-keyword\">const</span> state = {\n  users: [\n    { id: <span class=\"hljs-number\">1</span>, name: <span class=\"hljs-string\">\"Dominic Elm\"</span> },\n    { id: <span class=\"hljs-number\">2</span>, name: <span class=\"hljs-string\">\"Kwinten Pisman\"</span> },\n  ],\n  selectedUserId = <span class=\"hljs-number\">1</span>\n}\n\n<span class=\"hljs-comment\">// New State</span>\n<span class=\"hljs-keyword\">const</span> newState = { ...state, selectedUserId: <span class=\"hljs-number\">2</span> };\n</code></pre>\n<p>In this example, we have a state object with some data. We want to update the <code>selectedUserId</code> property, without mutating the original object. Using the object spread operator, we create a new object, keeping the same reference to the <code>users</code> array but updating the <code>selectedUserId</code> to 2.</p>\n<p><strong>Note:</strong> This is just one of the ways we can work immutable. The spread operator is available in the latest versions of JavaScript. There are also libraries that can help us to work immutable that will be more performant for big collections, for example <a href=\"https://facebook.github.io/immutable-js/\">Immutable.js</a>, <a href=\"https://github.com/mweststrate/immer\">Immer</a> or <a href=\"https://github.com/rtfeldman/seamless-immutable\">Seamless Immutable</a>. The point here is that we should embrace immutability and try to avoid mutating objects, regardless of how you accomplish this.</p>\n"
    },
    "Z1ohpIo": {
      "id": "Z1ohpIo",
      "slug": "sign-out",
      "category": "login",
      "title": "sign-out",
      "content": "<h3>Descrizione</h3>\n<p>Due to the way DI (Dependency Injection) in Angular is implemented, with an injector tree, we can provide instances of our service on multiple levels, e.g. component, directive or module. While this is a useful feature, this is not always what we want.</p>\n<p>Working with a shared module is quite common and recommended. This module can be used to share services, components, directives, pipes, etc. between different feature modules. If we import our shared module in multiple modules, we will provide the service multiple times and multiple instances will be created. Our services are no longer singletons.</p>\n<h3>Solution</h3>\n<p>When creating a <code>SharedModule</code>, we want to import the components in all feature modules but only provide the services in our root module, for instance <code>AppModule</code>. We can accomplish this by leveraging the <code>forRoot</code> convention. Here’s what our <code>SharedModule</code> would look like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [...modules],\n  declarations: [...declarations],\n  exports: [...declarations]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SharedModule {\n  <span class=\"hljs-keyword\">static</span> forRoot(): ModuleWithProviders {\n    <span class=\"hljs-keyword\">return</span> {\n      ngModule: SharedModule,\n      providers: [...services]\n    };\n  }\n}\n</code></pre>\n<p>Note that the actual module definition <strong>does not</strong> contain any providers.</p>\n<p>In our <code>AppModule</code>, we could use this module as follows:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n    ...modules,\n    SharedModule.forRoot()\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n<p>By calling the static <code>forRoot</code> method on the <code>SharedModule</code> we import the entire module <strong>including</strong> its providers.</p>\n<p>In a feature module we would simply import the <code>SharedModule</code> <strong>without</strong> calling <code>forRoot</code>:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n    ...modules,\n    SharedModule\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeFeature {}\n</code></pre>\n<p>The fact that each component has its own injector that inherits from its parent injector, allows us to ask for services provided on a root level. Therefore, we have access to all components, pipes, etc. provided by the <code>SharedModule</code> without creating multiple instances of its services.</p>\n<h3>Additional Resources</h3>\n<ul>\n<li><a href=\"https://blog.thoughtram.io/angular/2015/05/18/dependency-injection-in-angular-2.html\">Dependency Injection in Angular</a> by Pascal Precht</li>\n<li><a href=\"https://blog.thoughtram.io/angular/2016/09/14/bypassing-providers-in-angular-2.html\">Bypassing Providers in Angular</a> by Pascal Precht</li>\n<li><a href=\"https://blog.angularindepth.com/avoiding-common-confusions-with-modules-in-angular-ada070e6891f\">Avoiding common confusions with modules in Angular</a> by Maxim Koretskyi</li>\n</ul>\n"
    },
    "1pQWxn": {
      "id": "1pQWxn",
      "slug": "pannello-strumenti-cerca",
      "category": "stock",
      "title": "pannello strumenti -> cerca",
      "content": "<h3>Descrizione</h3>\n<p>With Angular we are creating applications using a layered architecture. Every layer in our application should have its own responsibility. This means we have decoupled layers and each with its own concern.\nBusiness logic in our application does not belong in the component layer. The component layer is purely meant to be used for visualization, displaying user interface and handling user input. Therefore, business logic should be extracted into the service layer.</p>\n<h3>Solution</h3>\n<p>In the following example, we are using the <code>HttpClient</code> to fetch data from a backend. This should not be done from the component layer but instead we move the logic into a dedicated service.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit {\n  data$;\n\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> http: HttpClient</span>) {}\n\n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.data$ = <span class=\"hljs-keyword\">this</span>.http.get(<span class=\"hljs-string\">'http://some-api.com/'</span>);\n  }\n}\n</code></pre>\n<p>We can refactor this and move the logic into a <code>PeopleService</code>.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit, OnDestroy {\n  data$;\n\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> peopleService: PeopleService</span>) {}\n\n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.data$ = <span class=\"hljs-keyword\">this</span>.peopleService.getPeople();\n  }\n}\n</code></pre>\n"
    },
    "NEzhm": {
      "id": "NEzhm",
      "slug": "pannello-strumenti-selezionati-salvati-recenti",
      "category": "stock",
      "title": "pannello strumenti -> selezionati, salvati, recenti",
      "content": "<h3>Descrizione</h3>\n<p>When applications grow over time, it can be quite hard to identify and find certain parts in our application. When we don’t give a descriptive name to our files, this makes it even more difficult to do so.</p>\n<h3>Solution</h3>\n<h4>Separate file names with dots and dashes</h4>\n<p>It is recommended to separate words with dashes and dots to separate the descriptive name from the type. The descriptive name of a file should describe the component’s feature.</p>\n<p>Also, try to use conventional suffix that describe the type of the file, e.g. <code>.component.ts</code>, <code>.directive.ts</code>, <code>.service.ts</code>, <code>.module.ts</code>, <code>.pipe.ts</code>.</p>\n<p>Here are a few examples:</p>\n<ul>\n<li><code>app.component.ts</code></li>\n<li><code>contacts.service.ts</code></li>\n<li><code>product-list.component.ts</code></li>\n</ul>\n<p>Using such naming convention helps to provide a consistent way to find content very quickly and easily. Consistency will save you time and make you and your team more efficient.</p>\n<h4>Use the name and type of the file for your class names</h4>\n<p>If the file you are working on is <code>app.component.ts</code> it is obvious that this must be a component. It also tells us the name of this component, which is <code>app</code>. This means we’d call our class <code>AppComponent</code>:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({ ... })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppComponent { }\n</code></pre>\n<p>Here’s another example of a class defined in <code>product-list.component.ts</code>:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({ ... })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> ProductListComponent { }\n</code></pre>\n"
    },
    "Z2qKc11": {
      "id": "Z2qKc11",
      "slug": "griglia-stock",
      "category": "stock",
      "title": "griglia stock",
      "author": {
        "name": "Billy Lando",
        "url": "https://github.com/billyjov"
      },
      "content": "<h3>Descrizione</h3>\n<p>As an app scales, the root module starts growing and declaring a vast number of components increases the start time as well as affects the application’s performance. Additionally, the more components we add to the root module, the harder it gets to understand the application’s structure, and therefore making it hard to maintain.</p>\n<h3>Solution</h3>\n<p>Using an <code>NgModule</code> to define features in Angular allows lazy loading, isolation and portability of this features. The purpose of feature modules is to organize relevant code into cohesive blocks. This helps to apply clear boundaries between features or application domains.</p>\n<p>Another benefit of <code>NgModules</code> is that they allow us to lazy load each feature module in order to boost the performance of our app, especially time to <strong>first meaningful paint</strong> (FMP). Furthermore, feature encapsulation using modules allow us to replace each module without (or with small changes) affecting other modules.</p>\n<p>Here’s an example:</p>\n<pre class=\"hljs\"><code>\n<span class=\"hljs-meta\">@Component</span>({ ... })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AddPeopleComponent <span class=\"hljs-keyword\">implements</span> OnInit {\n  ...\n}\n\n<span class=\"hljs-meta\">@Component</span>({...})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> ListPeopleComponent <span class=\"hljs-keyword\">implements</span> OnInit {\n  ...\n}\n\n<span class=\"hljs-meta\">@NgModule</span>({\n  ...\n  imports: []\n  declarations: [\n    AddPeopleComponent,\n    ListPeopleComponent\n    <span class=\"hljs-comment\">// other components</span>\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n<p>The above can be refactored to:</p>\n<pre class=\"hljs\"><code>\n<span class=\"hljs-meta\">@Component</span>({ ... })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AddPeopleComponent <span class=\"hljs-keyword\">implements</span> OnInit {\n  ...\n}\n\n<span class=\"hljs-meta\">@Component</span>({ ... })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> ListPeopleComponent <span class=\"hljs-keyword\">implements</span> OnInit {\n  ...\n}\n\n<span class=\"hljs-comment\">// introduce a new feature module</span>\n<span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n    CommonModule\n  ]\n  declarations: [\n    AddPeopleComponent,\n    ListPeopleComponent\n  ]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> PeopleModule {}\n\n\n<span class=\"hljs-meta\">@NgModule</span>({\n  ...\n  imports: [\n    <span class=\"hljs-comment\">// import our new feature module</span>\n    PeopleModule\n  ]\n  declarations: [\n    <span class=\"hljs-comment\">// other components</span>\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n<p>Alternatively, we can use lazy loading as described <a href=\"/default/checklist/router/Z165VzV\">here</a>.</p>\n<h4>What if something needs to be reused elsewhere?</h4>\n<p>In this case, using a <code>SharedModule</code> helps to organize reusable parts into its own module. We can put commonly used directives, pipes, and components into one module and then import the <code>SharedModule</code> wherever we need it in other parts of our application.\nBut we aware of possibly multiple service instances. For more information check <a href=\"/default/checklist/architecture/Z1ohpIo\">this item</a>.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://blog.angularindepth.com/avoiding-common-confusions-with-modules-in-angular-ada070e6891f\">Avoiding common confusions with modules in Angular</a> by Max Koretskyi</li>\n<li><a href=\"https://www.youtube.com/watch?v=ntJ-P-Cvo7o\">Module vs Module</a> by Deborah Kurata</li>\n<li><a href=\"https://angular.io/guide/feature-modules\">Angular documentation for Feature Modules</a></li>\n</ul>\n"
    },
    "Z1eHhoR": {
      "id": "Z1eHhoR",
      "slug": "user-grid-settings",
      "category": "stock",
      "title": "user grid settings",
      "content": "<h3>Descrizione</h3>\n<p>Every major frontend framework is moving towards a component-based architecture. Components are a combination of HTML, JavaScript and CSS. If we start injecting services in every component, tightly couple them by letting them fetch their own data, we are not leveraging the power of a component-based architecture.</p>\n<h3>Solution</h3>\n<p>The most advocated way to lay out your components is to use smart and dumb components (there is a variety of other names for this principle but the general idea is the same).</p>\n<h4>Component Types</h4>\n<h5>Dumb Component</h5>\n<ul>\n<li>Receives data through <code>@Input</code>s and communicates only with it’s direct parent through <code>@Output</code>s.</li>\n<li>Dumb components should not receive <code>Observables</code> as inputs.</li>\n<li>They do not know about the rest of the application and hence does not know where they are being used.</li>\n<li>Can contain business logic, but only logic that belongs to the scope of this component. For example, a pagination component can contain logic to calculate the number of ‘boxes’ to show. It does not know what happens when a user clicks a page number. In that case, it would emit a custom event to notify its parent that something has happened. The parent component then decides what to do and takes action.</li>\n<li>They can use other dumb components as children.</li>\n<li>They can inject services that are related to the view layer of your application (think <code>TranslateService</code>, <code>Router</code>, …) but never services that handle business logic such as fetching data.</li>\n</ul>\n<h5>Smart Component</h5>\n<ul>\n<li>Smart components are application-level components.</li>\n<li>They know how to fetch data and persist changes.</li>\n<li>They pass data down to dumb components as much as possible and mostly only contains business logic to fetch data.</li>\n<li>They compose several other dumb components in its template.</li>\n<li>They listen for events emitted by dumb components and perform the required action.</li>\n</ul>\n<h4>Benefits</h4>\n<ul>\n<li>Dumb components are completely reusable since they have a defined API and are independent of any business logic.</li>\n<li>Dumb components are easy to test as they are completely isolated.</li>\n<li>The entire architecture of your components becomes easier to reason about. If there is problem with business logic or if the data is not correctly fetched, you know that you need to start searching in your smart components since this is their only responsibility.</li>\n</ul>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\">Presentational and container components</a> by Dan Abramov</li>\n<li><a href=\"https://blog.angular-university.io/angular-2-smart-components-vs-presentation-components-whats-the-difference-when-to-use-each-and-why/\">Smart components vs presentational components</a> by Angular University</li>\n<li><a href=\"https://blog.strongbrew.io/the-smart-vs-dumb-components-quiz/\">The smart vs dumb component quiz</a> by Kwinten Pisman</li>\n</ul>\n"
    },
    "2eREkv": {
      "id": "2eREkv",
      "slug": "dettagli-veicolo",
      "category": "stock",
      "title": "dettagli veicolo",
      "content": "<h4>Problem</h4>\n<p>When creating Angular components, we need to use resources to get user input, fetch data from the backend, create animations, etc. The way we do this varies. We could use Observables, browser APIs, event listeners or other means. When using resources, we also need to release those resources when they are no longer required. If we do <strong>not</strong> do this, we might introduce memory leaks which will make our application crash and introduce other unwanted behavior.</p>\n<h4>Solution</h4>\n<p>For every component and directive, Angular offers lifecycle hooks that provide visibility into key life moments of a component, such as creation, rendering, or when data-bound properties have changed.</p>\n<p>In order to release our resources, we can hook into the <code>ngOnDestroy</code> lifecyle of a component. This hook is called <strong>before</strong> a component is destroyed and removed from the DOM.</p>\n<p>In the following example, we set up a function to be executed every 5000ms using the <code>setInterval</code> API. Inside <code>ngOnDestroy</code>, we clear the interval and release the resource.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit, OnDestroy {\n  intervalId;\n\n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.intervalId = setInterval(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {...}, <span class=\"hljs-number\">5000</span>);\n  }\n\n  ngOnDestroy() {\n    clearInterval(<span class=\"hljs-keyword\">this</span>.intervalId);\n  }\n}\n</code></pre>\n"
    },
    "2rF4Hq": {
      "id": "2rF4Hq",
      "slug": "configurazione-generale",
      "category": "settings",
      "title": "configurazione generale",
      "content": "<h3>Descrizione</h3>\n<p>Property bindings in Angular allows us to bind to properties. During change detection, when a component is checked, all of the bindings for that component are being checked to see if the view needs to be updated. This means that the more bindings we create, the slower the CD cycle will be, as more bindings need to be checked.</p>\n<p>If we have static strings that we want to pass to a native attribute (such as <code>id</code> and <code>title</code>) of an HTML element, it’s not necessary to use a property binding as the value will never change. This seems to be a trivial thing to talk about, but it can have a great impact the performance of our application.</p>\n<h3>Solution</h3>\n<p>Only use a property binding for dynamic values. Use attributes to pass static string values to native attributes.</p>\n<p>In the following example, we bind a static string to the <code>id</code> property of an input field. This doesn’t make much sense because this string is passed statically and will never change. So, why use a property binding for this?</p>\n<pre class=\"hljs\"><code>&lt;input [id]=<span class=\"hljs-string\">\"'exampleId'\"</span> /&gt;\n</code></pre>\n<p>In order to fix this, we can remove the property binding and use the native <code>id</code> attribute instead.</p>\n<pre class=\"hljs\"><code>&lt;input id=<span class=\"hljs-string\">\"exampleId\"</span> /&gt;\n</code></pre>\n"
    },
    "ZXcqct": {
      "id": "ZXcqct",
      "slug": "filtri-preimpostati",
      "category": "components",
      "title": "filtri preimpostati griglia stock",
      "content": "<h3>Descrizione</h3>\n<p>When we put too much logic in our templates, we are making our applications more difficult to test. The fastest way to write and execute tests is to use simple unit tests. Of course we could also test a component’s template with a unit test but that increases the complexity and introduces some challenges we have to deal with.</p>\n<p>In addition, too much logic inside the template makes them less readable. We cannot take a quick glance at the template and quickly understand what’s going on.</p>\n<h3>Solution</h3>\n<p>Try to avoid putting too much logic in your templates.</p>\n<p>For example here, we have have an <code>*ngIf</code> that has too much logic.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`&lt;div *ngIf=\"users &amp;&amp; users.length &gt; 1 &amp;&amp; visible\"&gt;content to show&lt;/div&gt;`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent {\n  users: User[];\n  visible: <span class=\"hljs-built_in\">boolean</span>;\n}\n</code></pre>\n<p>We can refactor this by extracting the logic into the component’s class. This will make the template more readable and the logic easier to test.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`&lt;div *ngIf=\"usersExistsAndVisible()\"&gt;content to show&lt;/div&gt;`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent {\n  users: User[];\n  visible: <span class=\"hljs-built_in\">boolean</span>;\n\n  usersExistsAndVisible() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.users &amp;&amp; <span class=\"hljs-keyword\">this</span>.users.length &gt; <span class=\"hljs-number\">1</span> &amp;&amp; <span class=\"hljs-keyword\">this</span>.visible;\n  }\n}\n</code></pre>\n"
    },
    "ZXTLWo": {
      "id": "ZXTLWo",
      "slug": "icone-status",
      "category": "settings",
      "title": "icone status griglia stock",
      "content": "<h3>Descrizione</h3>\n<p>The constructor is a function of a class that is being called during the construction of an instance of that component. Angular leverages the constructor to provide us with the dependencies we requested. It doesn’t mean however, that Angular is fully finished with the creation of this component. The <code>@Input</code> bindings for example will not be initialised yet. Angular will call the <code>ngOnInit</code> lifecycle hook when it’s ready.</p>\n<p>If we put logic inside the constructor, especially data-fetching logic, we are doing things before Angular has finished creating the component. It also has an impact on how we test our code. In a unit test, we will probably instantiate an instance of a component in a <code>beforeEach</code> block. If this already initialises some logic or fetches data, it will impact every other test and make it harder to test this particular logic.</p>\n<h3>Solution</h3>\n<p>To fix this, we need to move all initialization logic that needs to be tested and that uses <code>@Input</code> bindings to the <code>ngOnInit</code> lifecycle hook.</p>\n<p>The constructor should only be used for injecting dependencies.</p>\n<p>Here’s a concrete example.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`...`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent {\n  users$: Observable&lt;User&gt;;\n\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> usersService: UsersService</span>) {\n    <span class=\"hljs-keyword\">this</span>.users$ = <span class=\"hljs-keyword\">this</span>.usersService.getUsers();\n  }\n}\n</code></pre>\n<p>We refactor this by moving the code from the constructor into the <code>ngOnInit</code> lifecycle hook.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`...`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit {\n  users$: Observable&lt;User&gt;;\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> usersService: UsersService</span>) {}\n\n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.users$ = <span class=\"hljs-keyword\">this</span>.usersService.getUsers();\n  }\n}\n</code></pre>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://blog.angularindepth.com/the-essential-difference-between-constructor-and-ngoninit-in-angular-c9930c209a42\">The essential difference between Constructor and ngOnInit in Angular</a> by Maxim Koretskyi</li>\n</ul>\n"
    },
    "Z1eEvQQ": {
      "id": "Z1eEvQQ",
      "slug": "configurazione-griglie",
      "category": "settings",
      "title": "configurazione griglie",
      "author": {
        "name": "Billy Lando",
        "url": "https://github.com/billyjov"
      },
      "content": "<h3>Descrizione</h3>\n<p>According to the Angular documentation, relying on direct DOM access creates tight coupling between your application and rendering layers which will make it impossible to separate the two and deploy your application into a web worker.</p>\n<p>Consequently, using jQuery , <code>document</code> object, or <code>ElementRef.nativeElement</code> is not recommended as it’s not available on other platforms such as server (for server-side rendering) or web worker.</p>\n<p>In addition, permitting direct access to the DOM can make your application more vulnerable to <strong>XSS</strong> attacks.</p>\n<h3>Solution</h3>\n<p>Always try to prefer the <code>Renderer2</code> for DOM manipulations. It provides an API that can safely be used even when direct access to native elements is not supported.</p>\n<ul>\n<li><strong>Bad practice</strong></li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  ...\n  template: <span class=\"hljs-string\">`\n    &lt;textarea&gt;&lt;/textarea&gt;\n    &lt;my-child-component&gt;&lt;/my-child-component&gt;\n  `</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit {\n\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> elementRef: ElementRef</span>) {}\n    \n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.elementRef.nativeElement.style.backgroundColor = <span class=\"hljs-string\">'#fff'</span>;\n    <span class=\"hljs-keyword\">this</span>.elementRef.nativeElement.style.display = <span class=\"hljs-string\">'inline'</span>;\n    <span class=\"hljs-keyword\">const</span> textareaElement = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">'textarea'</span>);\n    <span class=\"hljs-keyword\">const</span> myChildComponent = $(<span class=\"hljs-string\">'my-child-component'</span>);\n  }\n}\n</code></pre>\n<p>We can refactor this by using a combination of <code>ElementRef</code> and <code>Renderer2</code>.</p>\n<ul>\n<li><strong>Good practice</strong></li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { MyChildComponent } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./my-child.component'</span>;\n\n<span class=\"hljs-meta\">@Component</span>({\n  ...\n  template: <span class=\"hljs-string\">`\n    &lt;textarea #textareaRef&gt;&lt;/textarea&gt;\n    &lt;my-child-component&gt;&lt;/my-child-component&gt;\n  `</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit {\n\n  <span class=\"hljs-meta\">@ViewChild</span>(<span class=\"hljs-string\">'textareaRef'</span>) myTextAreaRef: ElementRef;\n  <span class=\"hljs-meta\">@ViewChild</span>(MyChildComponent) myChildComponentRef: MyChildComponent;\n\n  <span class=\"hljs-keyword\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> elementRef: ElementRef, <span class=\"hljs-keyword\">private</span> renderer: Renderer2</span>) {}\n    \n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.renderer.setStyle(<span class=\"hljs-keyword\">this</span>.elementRef.nativeElement, <span class=\"hljs-string\">'backgroundColor'</span>, <span class=\"hljs-string\">'#fff'</span>);\n    <span class=\"hljs-keyword\">this</span>.renderer.setStyle(<span class=\"hljs-keyword\">this</span>.elementRef.nativeElement, <span class=\"hljs-string\">'display'</span>, <span class=\"hljs-string\">'inline'</span>);\n    <span class=\"hljs-keyword\">const</span> textareaElement = <span class=\"hljs-keyword\">this</span>.myTextAreaRef.nativeElement;\n    <span class=\"hljs-keyword\">const</span> myComponent = <span class=\"hljs-keyword\">this</span>.myChildComponent;\n  }\n}\n</code></pre>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://angular.io/api/core/ElementRef#description\">Angular Documentation for ElementRef</a></li>\n<li><a href=\"https://blog.angularindepth.com/exploring-angular-dom-abstractions-80b3ebcfc02\">Exploring Angular DOM manipulation techniques using ViewContainerRef</a> by Max Koretskyi</li>\n</ul>\n"
    },
    "1KaHiT": {
      "id": "1KaHiT",
      "slug": "regole-di-riqualificazione",
      "category": "settings",
      "title": "regole di riqualificazione",
      "author": {
        "name": "Billy Lando",
        "url": "https://github.com/billyjov"
      },
      "content": "<h3>Descrizione</h3>\n<p>The Angular team and community are continually improving the ecosystem to make it easier to build applications. Both the performance and the compiler (e.g Ivy Renderer) are constantly being improved for better web applications.</p>\n<p>Angular uses semantic versioning (semver) which means they use a regular schedule of releases. This includes a major release every six month, 1-3 minor releases for each major release, and a patch release almost every week. It’s important to keep up with major releases as they contain significant new features. The longer we wait to update our application, the more expensive will be a future update. Be aware, that major releases may contain breaking changes.</p>\n<p>In addition, when API’s get deprecated they remain present in the next two major releases until they are removed. Again, if we wait to long, it’s likely that the update requires much more work. You can read more about deprecations in the <a href=\"https://github.com/angular/angular/blob/master/CHANGELOG.md\">changelog</a>.</p>\n<h3>Solution</h3>\n<p>You can follow this steps using Angular CLI:</p>\n<ul>\n<li><strong>Step 1:</strong> Create a new feature branch</li>\n<li><strong>Step 2:</strong> Run <code>ng update @angular/core @angular/cli</code> inside your project directory</li>\n<li><strong>Step 3:</strong> Run <code>ng serve</code>, <code>ng test</code>, <code>ng build --prod</code> and make sure your app works as expected</li>\n<li><strong>Step 4:</strong> Fix update deprecations, issues, styling issues in case of Angular Material and run the previous step again</li>\n<li><strong>Step 5:</strong> merge or rebase your changes on top of the main branch</li>\n</ul>\n<p>For more information, check out the <a href=\"https://update.angular.io/\">official update guide</a> on how to update from different versions.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://angular.io/guide/updating\">Keeping your Angular Projects Up-to-Date</a></li>\n<li><a href=\"https://itnext.io/dont-be-afraid-and-just-ng-update-1ad096147640\">Don’t be afraid and just <code>ng update</code>!</a> by Bram Borggreve</li>\n</ul>\n"
    },
    "2oN0jv": {
      "id": "2oN0jv",
      "slug": "configurazione-tags",
      "category": "settings",
      "title": "configurazione tags",
      "content": "<h3>Descrizione</h3>\n<p><code>HttpClientModule</code> is responsible for providing us with HTTP related functionality. One such functionality is the ability to specify interceptors that inspect and transform HTTP requests from your application to the server.\nWhen re-importing <code>HttpClientModule</code> in a lazy-loaded module or a dependency of a lazy-loaded module, existing HTTP interceptors will be overridden for that module.</p>\n<h3>Solution</h3>\n<p>Import <code>HttpClientModule</code> only once in the root module.</p>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://github.com/angular/angular/issues/20575\">HTTP_INTERCEPTORS are reset when re-importing HttpClientModule</a></li>\n</ul>\n"
    }
  }
}
